<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yi's Blog - Do. Or do not. There is no try</title><link href="http://www.yilaguan.cc/" rel="alternate"></link><link href="http://www.yilaguan.cc/feeds/reading.atom.xml" rel="self"></link><id>http://www.yilaguan.cc/</id><updated>2015-11-24T00:00:00+08:00</updated><entry><title>重构_改善既有代码的设计</title><link href="http://www.yilaguan.cc/posts/2015/11/24/zhong-gou-_gai-shan-ji-you-dai-ma-de-she-ji.html" rel="alternate"></link><published>2015-11-24T00:00:00+08:00</published><author><name>YiHan</name></author><id>tag:www.yilaguan.cc,2015-11-24:posts/2015/11/24/zhong-gou-_gai-shan-ji-you-dai-ma-de-she-ji.html</id><summary type="html">&lt;h2&gt;第一章 重构、第一个案例&lt;/h2&gt;
&lt;h3&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，是特性的添加比较容易进行，然后再添加特性&lt;/li&gt;
&lt;li&gt;先看看有没有一套OK的测试机制，这些测试要有自我检测能力&lt;/li&gt;
&lt;li&gt;尽量干掉一些临时变量，但是需要考虑性能问题&lt;/li&gt;
&lt;li&gt;函数应该放在它所使用的数据的所属对象内&lt;/li&gt;
&lt;li&gt;考虑使用多态来替换那些if else, switch case - State 模式&lt;/li&gt;
&lt;li&gt;测试、小修改、测试、小修改、测试、小修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;该重构时就重构，自动化测试是前提，提炼函数，临时变量，switch case，变量名是重点
但是自动化测试一般没有，怎么破？&lt;/p&gt;
&lt;h2&gt;第二章 重构原则&lt;/h2&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对软件内部结构的一种调整， 目的是在不改变软件可观查行为的前提下，提高其可理解性，降低其修改成本&lt;/li&gt;
&lt;li&gt;使用一系列重构手法， 在不改变软件可观察行为的前提下，调整其结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为何重构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改进软件设计， 软件结构会流失， 重构维持其现有形态&lt;/li&gt;
&lt;li&gt;让软件更易理解&lt;/li&gt;
&lt;li&gt;帮助找到bug&lt;/li&gt;
&lt;li&gt;提高编程速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;何时重构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次就去做吧，第二次会不爽，忍忍， 第三次就重构吧&lt;/li&gt;
&lt;li&gt;添加功能时，如果发现不能轻松的添加你想要的功能，那就先重构他，然后再添加新功能&lt;/li&gt;
&lt;li&gt;代码复审时重构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么跟经理说&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;质量驱动 - 提&lt;/li&gt;
&lt;li&gt;进度驱动 - 不提，直接重构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;重构为什么有用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;现状&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难以阅读，难以修改&lt;/li&gt;
&lt;li&gt;逻辑重复，难以修改&lt;/li&gt;
&lt;li&gt;添加新逻辑，修改现有代码，难以修改&lt;/li&gt;
&lt;li&gt;复杂逻辑条件，难以修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易阅读&lt;/li&gt;
&lt;li&gt;所有逻辑都只在唯一地点指定&lt;/li&gt;
&lt;li&gt;新的改动不会危及现有逻辑&lt;/li&gt;
&lt;li&gt;尽可能简单表达条件逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;间接层与重构&lt;/h3&gt;
&lt;p&gt;计算机是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决，一顿还是两顿烧烤？&lt;/p&gt;
&lt;p&gt;重构很多时候就是在增加间接层，大对象拆分成小对象，大函数拆成小函数
优点：
- 允许逻辑共享
- 分开解释意图和实现&lt;br /&gt;
    - 其实就是给函数或者类取个好名字
- 隔离变化
- 封装条件逻辑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重构 VS 事前设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码的坏味道&lt;/h2&gt;
&lt;p&gt;什么时候需要重构呢？？
代码改动困难，牵一发而动全身时，一个相同处理逻辑遍地都是的时候，就重构吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复代码&lt;ul&gt;
&lt;li&gt;重复代码永远是一个警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过长函数&lt;/li&gt;
&lt;li&gt;过大的类&lt;/li&gt;
&lt;li&gt;过长的参数列表&lt;/li&gt;
&lt;li&gt;发散式变化&lt;ul&gt;
&lt;li&gt;一个类收到多种情况变化的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;散弹式修改&lt;ul&gt;
&lt;li&gt;一个变化引发多个类相应修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依恋情结&lt;ul&gt;
&lt;li&gt;一个函数过度依赖于另外一个对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据泥团&lt;ul&gt;
&lt;li&gt;让有关联关系的数据组成一个对象，在对象内部进行一些处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本类型偏执&lt;ul&gt;
&lt;li&gt;不要介意使用一些小的类，比如数值和币种的money类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Switch&lt;ul&gt;
&lt;li&gt;使用多态，状态类，子类继承等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平行继承体系&lt;ul&gt;
&lt;li&gt;干掉引用端的继承体系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冗余类&lt;ul&gt;
&lt;li&gt;inline class&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;夸夸奇谈未来性&lt;ul&gt;
&lt;li&gt;需求实现不用太过超前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;令人迷惑的暂时字段-class fileds&lt;ul&gt;
&lt;li&gt;将字段和与之相关的计算独立出来，作为一个新的函数对象维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过度耦合的消息链条&lt;ul&gt;
&lt;li&gt;用函数替代对象链条&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中间人 【过度委托】&lt;/li&gt;
&lt;li&gt;类过于亲密&lt;/li&gt;
&lt;li&gt;异曲同工的类&lt;/li&gt;
&lt;li&gt;不完美的库类&lt;/li&gt;
&lt;li&gt;纯粹的数据类&lt;/li&gt;
&lt;li&gt;被拒绝的馈赠&lt;ul&gt;
&lt;li&gt;基类继承了过多的父类的实现，这个一般可以接受，如果不愿意实现父类的接口，就注意是否要继续继承，可以考虑是否要修改继承关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过多的注释&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;构筑测试体系&lt;/h2&gt;
&lt;p&gt;可靠的测试体系是重构的前提。&lt;/p&gt;
&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;p&gt;这本书后面部分大部分是一些具体的重构手法，会快速过一下，就不再笔记了。  &lt;/p&gt;
&lt;p&gt;最大的收获莫过于减少了对重构的顾虑，更加重视自动测试体系，开始在EBS plsql开发的过程使用自动测试。&lt;br /&gt;
开发过程中虽然多花了一些时间编写自动测试脚本，但是一旦编写完成，修改一点代码就可以很快的进行一次批量测试，对开发速度的提升还是很明显的。  &lt;/p&gt;
&lt;p&gt;有了测试体系，该重构时就重构吧。&lt;/p&gt;</summary><category term="Reading"></category><category term="Refactoring"></category></entry></feed>